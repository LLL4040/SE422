# Omega### 解决的问题#### 目前的分布式系统的瓶颈问题，传统的调度方法要么不够灵活，要么效率和使用效率低，提供了一种新的调度方法Omega优化这些问题### 解决方法#### Omega使用的替代方法是共享状态方法：我们授予每个调度程序对整个集群的完全访问权限，允许他们以自由共享的方式进行竞争，并在它们更新集群状态时使用乐观并发控制来调解冲突。#### 这立即消除了两级调度程序方法中的两个问题-由于悲观的并发控制而导致的并行性受限，以及调度程序框架中的资源可见性受到限制-以乐观并发假设不正确时重做工作的潜在成本。#### Omega中没有中央资源分配器； 所有资源分配决策都在调度程序中进行。每个调度程序都获得一个专用的，本地的，频繁更新的单元状态副本，用于执行调度决策。如果调度程序具有适当的权限和优先级，即使是另一个调度程序已经获得的权限和优先级，调度程序也可以看到该单元的整个状态，并拥有对任何可用群集资源主张所有权的完全自由一旦调度程序做出放置决策，它将在原子提交中更新单元状态的共享副本。在冲突的情况下，这样的提交最多将成功：有效地，从状态同步到提交尝试的时间是一个事务。事务是否成功，调度程序之后将重新同步其单元状态的本地副本，并在必要时重新运行其调度算法，然后重试。#### Omega调度程序完全并行运行，无需等待其他调度程序中的作业，并且没有调度程序内部行头阻塞。为了防止冲突导致饥饿，Omega调度程序通常选择使用增量事务，该事务接受所有冲突的变更（即，事务提供了原子性，但不提供独立性）。调度程序可以改为使用“不存在任何事务”来实现帮派调度：要么一起调度所有任务，要么没有一起调度，并且调度器必须尝试再次调度整个任务。### 主要技术#### 采用乐观锁提高并发度，并发提高，公平性降低，主要符合需求### 感想#### Omega是比较新的一种系统，随着需求的变化而诞生的。Omega和kubernate不同的是，Omega把存储直接暴露给信任的控制面板的组件，而在Kubernete中，是要完全由domain-specific的提供更高一层的版本控制认证、语义、政策的REST API来接触，以服务更多的用户。更重要的是，Kubernetes是由一支在集群层面应用开发能力更强的开发者开发的，他们主要的设计目标是用更容易的方法去部署和管理复杂的分布式系统，同时仍然能通过容器所提升的使用效率来受益。